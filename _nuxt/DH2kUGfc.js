function h(r){r.sort((e,o)=>e[0]-o[0]);const s=[];for(const e of r){const o=s[s.length-1];o&&o[1]>=e[0]?o[1]=Math.max(o[1],e[1]):s.push(e)}return s}function p(r,s,e){const o=h(s).sort((n,a)=>a[0]-n[0]);let t=r;for(const n of o){const a=n[1]-n[0];t=t.slice(0,n[0])+t.slice(n[1]),e==null||e.forEach(i=>{i.start+i.length<=n[0]||(i.start<n[1]?i.start=-1:i.start-=a)})}return{code:t,removals:o,nodes:e}}var d=Object.defineProperty,f=(r,s,e)=>s in r?d(r,s,{enumerable:!0,configurable:!0,writable:!0,value:e}):r[s]=e,c=(r,s,e)=>(f(r,typeof s!="symbol"?s+"":s,e),e);class m extends Error{constructor(s,e,o,t){let n=`
## ${s}

${e}
`;o&&(n+=`
${o}`),t&&(n+=`
${t}`),super(n),c(this,"title"),c(this,"description"),c(this,"recommendation"),c(this,"code"),this.title=s,this.description=e,this.recommendation=o,this.code=t}}const g=/^\/\/\s?@(\w+)$/mg,x=/^\/\/\s?@(\w+):\s?(.+)$/mg,v=/^\s*\/\/\s*\^(\?|\||\^+)( .*)?$/mg,y=/^\/\/\s?---cut(-before)?---\r?\n/mg,C=/^\/\/\s?---cut-after---$/mg,w=/^\/\/\s?---cut-start---$/mg,E=/^\/\/\s?---cut-end---\r?\n/mg;function I(r,s){const e=[],o=[...r.matchAll(y)],t=[...r.matchAll(C)],n=[...r.matchAll(w)],a=[...r.matchAll(E)];if(o.length){const i=o[o.length-1];e.push([0,i.index+i[0].length])}if(t.length){const i=t[0];e.push([i.index,r.length])}if(n.length!==a.length)throw new m("Mismatched cut markers",`You have ${n.length} cut-starts and ${a.length} cut-ends`,"Make sure you have a matching pair for each.");for(let i=0;i<n.length;i++){const u=n[i],l=a[i];if(u.index>l.index)throw new m("Mismatched cut markers",`You have a cut-start at ${u.index} which is after the cut-end at ${l.index}`,"Make sure you have a matching pair for each.");e.push([u.index,l.index+l[0].length])}return s&&s.removals.push(...e),e}const A=["all","allowArbitraryExtensions","allowImportingTsExtensions","allowJs","allowSyntheticDefaultImports","allowUmdGlobalAccess","allowUnreachableCode","allowUnusedLabels","alwaysStrict","assumeChangesOnlyAffectDirectDependencies","baseUrl","build","charset","checkJs","composite","customConditions","declaration","declarationDir","declarationMap","diagnostics","disableReferencedProjectLoad","disableSizeLimit","disableSolutionSearching","disableSourceOfProjectReferenceRedirect","downlevelIteration","emitBOM","emitDeclarationOnly","emitDecoratorMetadata","errors","esModuleInterop","exactOptionalPropertyTypes","experimentalDecorators","explainFiles","extendedDiagnostics","forceConsistentCasingInFileNames","generateCpuProfile","generateTrace","help","help","ignoreDeprecations","importHelpers","importsNotUsedAsValues","incremental","init","inlineSourceMap","inlineSources","isolatedModules","jsx","jsxFactory","jsxFragmentFactory","jsxImportSource","keepNotations","keyofStringsOnly","lib","listEmittedFiles","listFiles","listFilesOnly","locale","mapRoot","maxNodeModuleJsDepth","module","moduleDetection","moduleResolution","moduleSuffixes","newLine","noEmit","noEmitHelpers","noEmitOnError","noErrorTruncation","noErrorValidation","noErrors","noErrorsCutted","noFallthroughCasesInSwitch","noImplicitAny","noImplicitOverride","noImplicitReturns","noImplicitThis","noImplicitUseStrict","noLib","noPropertyAccessFromIndexSignature","noResolve","noStaticSemanticInfo","noStrictGenericChecks","noUncheckedIndexedAccess","noUnusedLocals","noUnusedParameters","out","outDir","outFile","paths","plugins","preserveConstEnums","preserveSymlinks","preserveValueImports","preserveWatchOutput","pretty","project","reactNamespace","removeComments","resolveJsonModule","resolvePackageJsonExports","resolvePackageJsonImports","rootDir","rootDirs","showConfig","showEmit","showEmittedFile","skipDefaultLibCheck","skipLibCheck","sourceMap","sourceRoot","strict","strictBindCallApply","strictFunctionTypes","strictNullChecks","strictPropertyInitialization","stripInternal","suppressExcessPropertyErrors","suppressImplicitAnyIndexErrors","target","traceResolution","tsBuildInfoFile","typeRoots","types","useDefineForClassFields","useUnknownInCatchVariables","verbatimModuleSyntax","version","watch"];function b(r,s){const e={removals:[]},o=[...s??[],...A];return Array.from(r.matchAll(g)).forEach(t=>{o.includes(t[1])&&e.removals.push([t.index,t.index+t[0].length+1])}),Array.from(r.matchAll(x)).forEach(t=>{o.includes(t[1])&&e.removals.push([t.index,t.index+t[0].length+1])}),I(r,e),Array.from(r.matchAll(v)).forEach(t=>{const n=t.index;e.removals.push([n,n+t[0].length+1])}),p(r,e.removals).code}export{b as removeTwoslashNotations};
